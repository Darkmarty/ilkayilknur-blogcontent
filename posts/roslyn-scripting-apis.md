# Roslyn Scripting APIs #

Bir önceki [yazımızda](http://ilkayilknur.com/c-sharp-interactive-window) Visual Studio 2015 Update 1 ile gelen Interactive Window'u incelemiştik. Interactive Window ile C# kodlarını Visual Studio içerisinde hızlı bir şekilde çalıştırıp anında sonuçlarını görebiliyoruz. Nasıl browserda console içerisinde script çalıştırıp sonucunu anında görebiliyorsak aynısını artık C# için de yapabiliyoruz. Peki bu nasıl mümkün oluyor ?

Aslında tüm sihir Roslyn'in scripting API'larında. Yani Interactive Window içerisinde bir kod yazdığınızda bu kod scripting API'ları aracılığıyla Roslyn'e gönderiliyor ve arkada derlenip, çalıştırılıp sonucu bize geri veriliyor. Şimdi isterseniz gelin bu scripting API'larına biraz gözatalım. 

Scripting API'larına ulaşabilmemiz için projemize ilk olarak **Microsoft.CodeAnalysis.Scripting** nuget paketini yüklememiz gerekiyor. 

	PM> Install-Package Microsoft.CodeAnalysis.Scripting

Nuget paketini yüklediğimiz proje eğer .NET Framework 4.6'yı target etmiyorsa aşağıdaki hatayı alıyoruz. Bu hatayı almamak için projemizi .NET Framework 4.6'ya yükseltmemiz gerekiyor.

> Could not install package 'System.Runtime 4.0.20'. You are trying to install this package into a project that targets '.NETFramework,Version=v4.5.2', but the package does not 
contain any assembly references or content files that are compatible with that framework

Nuget paketini başarılı bir şekilde yükledikten sonra artık scripting API'larını test etmeye hazırız. Genel olarak C# kodlarını çalıştırmak için kullanacağımız tipler **Microsoft.CodeAnalysis.CSharp.Scripting** namespace'i içerisinde bulunuyor.

İlk olarak en basit olandan başlıyoruz. **CSharpScript.EvaluateScript** metodu bizim basit C# ifadelerini çalıştırıp sonuçlarını almamızı sağlayan metot.

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Program</span><br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/> <br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;result&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="color:#2b91af;">CSharpScript</span>.EvaluateAsync(<span style="color:#a31515;">&quot;1+1&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;result2&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="color:#2b91af;">CSharpScript</span>.EvaluateAsync&lt;<span style="color:blue;">int</span>&gt;(<span style="color:#a31515;">&quot;1+1&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">$&quot;result:</span>{result}<span style="color:#a31515;">,&nbsp;result2:</span>{result2}<span style="color:#a31515;">&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}</pre>

![](https://ilkayblog.blob.core.windows.net/uploads/2016/01/Evaluate1.png)

Eğer EvaluateAsync'in generic olmayan metodunu kullanırsak bize sonuç **object** tipinden dönüyor. Ancak generic metodu kullanırsak **strongly-typed** olarak script'in sonucunu alabiliyoruz.

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Program</span><br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/> <br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;result&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="color:#2b91af;">CSharpScript</span>.EvaluateAsync&lt;<span style="color:blue;">int</span>&gt;(<span style="color:#a31515;">&quot;int&nbsp;x=10;int&nbsp;y=12;&nbsp;int&nbsp;z=x+y;&nbsp;z&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">$&quot;result:</span>{result}<span style="color:#a31515;">&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}</pre>

![](https://ilkayblog.blob.core.windows.net/uploads/2016/01/Evaluate2.png)

Yukarıda yazdığımız koda tekrar bakmamızda fayda var. "int x=10;int y=12; int z=x+y; z" aslında derlenebilir bir C# kodu değil. Ancak scripting API'larında bir değişkenin o anki değerini alabilmek için doğrudan adını yazdığımızda değerini alabiliyoruz. Aynı diğer scripting ortamlarında olduğu gibi.

**EvaluateAsync** metodu opsiyonel ikinci parametre olarak bizden **ScriptOptions** tipinde bir object bekliyor. Bu parametre ile istediğimiz namespace'i veya kütüphaneyi referans olarak ekleyebiliyoruz. Böylece EvaluateAsync içerisinde çalıştıracağımız kodlarda eklediğimiz kütüphanelerden ve namespacelerden tipleri kullanabiliyoruz. Eğer bu namespaceleri veya kütüphaneleri eklemezsek runtimeda scriptin derlenmesi esnasında compilation error alırız. 

Örneğin C# 6.0 ile beraber static tiplerin isimlerini using ile eklediğimizde kod içerisinde artık doğrudan tipin ismini kullanmadan metodun adıyla çağrım yapabiliyorduk. Math sınıfı içerisindeki Tan metodunu çağırdığımız aşağıdaki kodu düşünelim. 

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>}<br/> <br/><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">try</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;result&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="color:#2b91af;">CSharpScript</span>.EvaluateAsync&lt;<span style="color:blue;">int</span>&gt;(<span style="color:#a31515;">&quot;Tan(20);&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">$&quot;result:</span>{result}<span style="color:#a31515;">&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">catch</span>&nbsp;(<span style="color:#2b91af;">CompilationErrorException</span>&nbsp;ex)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(ex.ToString());<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}</pre>

Bu kodu çalıştırdığımızda compilation error alırız. Çünkü using ifadesi ile Math tipini script içerisinde referans almadık.

![](https://ilkayblog.blob.core.windows.net/uploads/2016/01/EvaluateEx.png) 

Eğer aşağıdaki gibi System.Math namespace'ini script içerisine referans olarak eklersek Tan(20) kodu başarılı olarak çalışacak ve sonucunu alabileceğiz.

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>}<br/> <br/><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">try</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;result&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="color:#2b91af;">CSharpScript</span>.EvaluateAsync&lt;<span style="color:blue;">double</span>&gt;(<span style="color:#a31515;">&quot;Tan(90);&quot;</span>,&nbsp;<span style="color:#2b91af;">ScriptOptions</span>.Default.WithImports(<span style="color:#a31515;">&quot;System.Math&quot;</span>));<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">$&quot;result:</span>{result}<span style="color:#a31515;">&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">catch</span>&nbsp;(<span style="color:#2b91af;">CompilationErrorException</span>&nbsp;ex)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(ex.ToString());<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}</pre>

Şimdiye kadar yaptığımız örneklerden de gördüğünüz üzere EvaluateAsync metodu context bağımsız olarak çalışıyor. Yani bir kod veriyorsunuz, derleyip, kodu çalıştırıyor ancak sonrasında içerisindeki tüm değişkenler ve değerleri kaybolup gidiyor. Peki ya aynı interactive window senaryosunda olduğu gibi çalıştıracağımız kodu dışarıdan alıyorsak ve bu kodu da çalıştırdığımız contexti korumak istiyorsak ne yapacağız ? İşte tam burada devreye **EvaluateAsync** metodunun biraz daha gelişmiş versiyonu olan **RunAsync** metodu devreye giriyor.

RunAsync metodu EvaluateAsync metodunun aksine bize **ScriptState** tipinde bir object döndürüyor. Bu object de kodu çalıştırdığımız contexti içerisinde barındırıyor. 

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>}<br/> <br/><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;state&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="color:#2b91af;">CSharpScript</span>.RunAsync&lt;<span style="color:blue;">int</span>&gt;(<span style="color:#a31515;">&quot;1+2&quot;</span>);<br/>}</pre>

ScriptState içerisindeki property ve metotlara kısaca bakarsak.

![](https://ilkayblog.blob.core.windows.net/uploads/2016/01/ScriptState.PNG)

- **ContinueWithAsync** metotları tahmin edeceğiniz üzere mevcut context üzerinden yeni kodlar çalıştırmamızı sağlar. 
- **GetVariable** metodu script içerisinde o anda tanımlı olan belirli bir değişkenle ilgili bilgileri alabilmemizi sağlar. 
- **ReturnValue** ise çalıştırdığımız kodun geri dönüş değerini içerir. EvaluteAsync metodundan doğrudan dönen değer burada **ReturnValue** propertysinde bulunuyor.
- **Script** propertysi son çalıştırdığımız script ile ilgili bilgileri saklar. 
- **Variables** propertysi ise script içerisinde o anda tanımlı olan tüm değişkenlerler ile ilgili bilgileri içerisinde barındırır.

Şimdi ContinueWithAsync ile ufak bir örnek yapalım.

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>}<br/> <br/><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;state&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="color:#2b91af;">CSharpScript</span>.RunAsync&lt;<span style="color:blue;">int</span>&gt;(<span style="color:#a31515;">&quot;1+2&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(state.ReturnValue);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;state2&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;state.ContinueWithAsync(<span style="color:#a31515;">&quot;int&nbsp;i=1;&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;state3&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;state2.ContinueWithAsync&lt;<span style="color:blue;">int</span>&gt;(<span style="color:#a31515;">&quot;i+5&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(state3.ReturnValue);<br/>}</pre>

Yukarıda görüldüğü gibi öncelikle basit bir toplama işlemi çalıştırdık. Sonrasında aynı context içerisinden devam edip bir değişken tanımladık. Bir sonraki adımda  ise bu değişkeni kullanarak bir toplama işlemi daha yaptık. Burada en çok dikkat çekmek istediğim nokta buradaki işlemlerden dönen tiplerin **immutable** olması. Yani her yeni script çalıştırışımızda bize **yeni bir ScriptState nesnesi** geliyor. Aslında baktığımızda bu state nesnelerini uygun bir şekilde saklarsak ihtiyacımıza göre ilgili kodları hiç çalıştırmamış gibi bir önceki state üzerinden devam etme imkanına da sahip olabiliriz.

Yukarıdaki kodun çıktısını aşağıda görebilirsiniz.


![](https://ilkayblog.blob.core.windows.net/uploads/2016/01/RunAsyncResult.PNG)

Yukarıda ScriptState tipi içerisinde script içerisinde tanımladığımız değişkenlerle ilgili bilgileri içerisinde saklar demiştik. Şimdi bununla ilgili de ufak bir örnek yapalım.

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>}<br/> <br/><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;state&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;<span style="color:#2b91af;">CSharpScript</span>.RunAsync(<span style="color:#a31515;">&quot;int&nbsp;x=1;&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;PrintVariables(state);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;state2&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;state.ContinueWithAsync(<span style="color:#a31515;">&quot;x=4;&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;PrintVariables(state2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;state3&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;state2.ContinueWithAsync(<span style="color:#a31515;">&quot;x=10;&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;PrintVariables(state3);<br/>}<br/> <br/><span style="color:blue;">private</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;PrintVariables(<span style="color:#2b91af;">ScriptState</span>&nbsp;state)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;variable&nbsp;<span style="color:blue;">in</span>&nbsp;state.Variables)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">$&quot;Variable&nbsp;Name:&nbsp;</span>{variable.Name}<span style="color:#a31515;">,Type:&nbsp;</span>{variable.Type.Name}<span style="color:#a31515;">,&nbsp;Value:&nbsp;</span>{variable.Value}<span style="color:#a31515;">&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}</pre>

ScriptState nesnesi o anda script içerisinde tanımlı olan değişkenlerle ilgili isim,tip ve o anki değeri gibi bilgileri içerisinde barındırıyor. Dolayısıyla bizde bu nesne üzerinden değişkenlerle ilgili bilgilere ulaşabiliyoruz. 

Yukarıdaki kodun çıktısına bakarsak.

![](https://ilkayblog.blob.core.windows.net/uploads/2016/01/ScriptStateVariables.png)

Yukarıdaki çıktıyla beraber kodu beraber incelersek her bir state nesnesi içerisinde değişkenin değerinin değiştiğini görüyoruz. 

**CSharpScript** tipi içerisinde son olarak **Create** statik metodunu kullanarak da script çalıştırabiliyoruz. Ancak bu metot diğerlerinden biraz farklı. Öncelikle bu metodu çağırdığımızda parametre olarak verdiğimiz kod anında çalıştırılmıyor. Çalıştırma operasyonunu scripti yarattıktan sonra bizim tetiklememiz gerekiyor. 

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>}<br/> <br/><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;script&nbsp;=&nbsp;<span style="color:#2b91af;">CSharpScript</span>.Create(<span style="color:#a31515;">&quot;1+2&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;state&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;script.RunAsync();<br/>}</pre>

Ayrıca burada diğer metotlardan farklı olarak script olarak verdiğimiz kodun derlenmesi **RunAsync** metodunu ilk çağırışımızda yapılıyor. Eğer istersek biz de **Compile** metodunu kullanarak derleme işlemini önceden tetikleyebiliyoruz. 

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>}<br/> <br/><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;script&nbsp;=&nbsp;<span style="color:#2b91af;">CSharpScript</span>.Create(<span style="color:#a31515;">&quot;1+2&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;script.Compile();<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;state&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;script.RunAsync();<br/>}</pre>

Script tipi üzerinden script çalıştırdığımızda bu tip içerisinde kodu derlemek için gerekli olan tüm yapılar(syntax tree vs...) saklanıyor. Bu nedenle eğer hep aynı kodu çalıştıracaksak bu yapılar bizim için ekstra yük demek. Bunun için CreateDelegate metodunu kullanarak içerisinde bu ekstra yapıları içermeyen daha basit bir tip elde edebiliriz ve bu tip üzerinde kodu daha hızlı ve efektif şekilde çalıştırabiliriz. 

<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Main(<span style="color:blue;">string</span>[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;RunAsync().Wait();<br/>}<br/> <br/><span style="color:blue;">static</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;RunAsync()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;script&nbsp;=&nbsp;<span style="color:#2b91af;">CSharpScript</span>.Create(<span style="color:#a31515;">&quot;1+2&quot;</span>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;runner&nbsp;=&nbsp;script.CreateDelegate();<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;result&nbsp;=&nbsp;<span style="color:blue;">await</span>&nbsp;runner();<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Console</span>.WriteLine(result);<br/>}</pre>

Yukarıdaki kodu bilgisayarınızda çalıştırırsanız delegate yaratma aşamasının biraz vakit aldığını ancak sonrasında delegate'i çalıştırma işleminin çok hızlı olduğunu göreceksiniz.

Roslyn içerisinde scripting API'larının kullanımları bu şekilde. Gördüğünüz gibi API'ların hepsi oldukça kuvvetli ve çok farklı senaryolara da cevap verebilecek şekilde tasarlanmış. Bu API'lar kullanılarak Interactive Window gibi daha pek çok farklı uygulama da yapılabilir. Örneğin web sayfası üzerinden aldığınız kodları serverda çalıştırıp sonuçlarını yine web sayfası üzerinde gösterebilirsiniz. Böylece kullanıcılar için ufak bir playground yapmış olabilirsiniz.  

Roslyn'in Scripting API'ları da aynı compilerlar gibi open source. Eğer bakmak isterseniz [buradan](https://github.com/dotnet/roslyn/tree/master/src/Scripting) ulaşabilirsiniz. Aynı şekilde Interactive Window Scripting API'ları kullanılarak nasıl yazılmış merak ediyorsanız [Github](https://github.com/dotnet/roslyn/tree/master/src/InteractiveWindow) üzerinden kodlarına ulaşabilirsiniz.

Bir sonraki yazıda görüşmek üzere
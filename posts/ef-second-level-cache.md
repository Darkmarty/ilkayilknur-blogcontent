Geliştirdiğimiz uygulamalar büyüdükçe ve karmaşıklaştıkca uygulamaların kullandıkları databaselere de erişimler  artmakta. Uygulamanın aldığı request sayısı arttıkça bir noktadan sonra her işlem için database'e gitmek uygulamanın performansını gözlü görülür bir biçimde etkilemekte. Özellikle uygulamanız içerisinde readonly tablelarınız varsa bu tablelara attığınız sorguların yanıtlarını cacheleyip bir sonraki requestte database'e gitmeden cachelenmiş datadan işlem yapmak uygulamanızın performansını arttıracaktır.

Entity Framework tarafındaki cache yapısına baktığımızda aslında DbContext içerisinde bir caching yapısı olduğunu görüyoruz. First level cache dediğimiz bu cache elinizde bulunan DbContext ile yaşıyor ve DbContext'i dispose ettiğinizde de elinizden gidiyor. Aslında bu bile bir noktaya kadar size performans açısından fayda sağlar. Ancak yukarıda bahsettiğimiz gibi database'den dönen sorgu sonucunu kendisinden sonra gelecek olan sorgularda da kullanabiliyor olmak daha da kritik bir öneme sahip. İşte bu noktada second-level cache devreye giriyor.

Entity Framework içerisine baktığımızda aslında default olarak gelen veya tek bir config değeriyle aç&kapa yapılabilecek bir second-level cache implementasyonu olmadığını görüyoruz. Aslında Entity Framework 6 ile gelen Interception yapısıyla second-level caching yapabilmek çok da zor değil. Neyse ki Microsoft'ta EF ekibinden bir kişi bu işe girişmiş ve second-level cache implementasyonunu yapmış. Proje sayfasına [codeplex](https://efcache.codeplex.com/) üzerinden ulaşabilirsiniz.

Şimdi gelelim bu implementasyonu uygulamalarımızda nasıl kullanacağımıza. Öncelikli olarak Nuget üzerinden libraryi projemize ekliyoruz.

**PM> Install-Package EntityFramework.Cache**

Library'i projeye ekledikten sonra gelelim second-level cache'i enable etme kısmına. Eğer entity framework configuration class'ınız varsa doğrudan bu class içerisinden ilerleyebilirsiniz. Eğer böyle bir classınız yoksa `DbConfiguration` classından türeyen bir configuration classı yazmak gerekiyor.

<pre style="font-family:Consolas;font-size:19;color:black;background:white;"><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MyDbConfiguration</span>&nbsp;:&nbsp;<span style="color:#2b91af;">DbConfiguration</span><br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;MyDbConfiguration()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;transactionHandler&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">CacheTransactionHandler</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">InMemoryCache</span>());<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddInterceptor(transactionHandler);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;cachingPolicy&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">CachingPolicy</span>();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loaded&nbsp;+=<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sender,&nbsp;args)&nbsp;=&gt;&nbsp;args.ReplaceService&lt;<span style="color:#2b91af;">DbProviderServices</span>&gt;(<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s,&nbsp;_)&nbsp;=&gt;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">CachingProviderServices</span>(s,&nbsp;transactionHandler,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cachingPolicy));<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}</pre>

Classı yazdıktan sonra yukarıda gördüğünüz gibi database operasyonları arasına girecek olan bir interceptor register ediyoruz. Bu register ettiğimiz `CacheTransactionHandler` tipi de zaten EF second-level cache librarysi içerisinde bulunuyor. Sonrasında da `CachingPolicy` vererek hızlı bir şekilde implementasyonu şimdilik bitiriyoruz. Tüm bunları yaptıktan sonra default değerlerle EF second-level cache hizmetinizde. Default değerlere göre database'den dönen değerler memoryde **sonsuza** kadar cachelenecek.

Biraz daha derinlere inip baktığımızda aslında entity framework'ün second-level cache kütüphanesi içerisinde bir dictionary tutuğunu ve bu dictionary içerisinde de key-value şeklinde db'den dönen yanıtları sakladığını görüyoruz. Peki key olarak hangi değer kullanılıyor diye sorduğumuzda ise içerisinde şu şekilde bir implementasyon olduğunu görüyoruz.

Key={DBName}-{SQLQuery}

Yukarıdaki key yapısına baktığımızda 2 farklı sonuç çıkarabiliriz. Bunlardan biri eğer uygulamanız multi-tenant bir uygulama ise yani aynı DbContext nesnesiyle farklı databaseleri sorguluyorsanız second-level cache bunu başarılı bir şekilde yönetebiliyor. Bir diğer konu da SQL Query bazında cacheleme yapması. Yani EF ile yaptığınız iki farklı sorgu sonucunda ikisinde de aynı entityler dönüyorsa bu entityler 2 kere cachelenecek. Bunu da göz önünde bulundurmakta fayda var.

Entity Framework second-level cache ile ilgili temel konulara değindik. Şimdi geldi sıradaki özelleştirme bölümüne.

## Farklı Cache Store Providerlar ##

Entity Framework second level cache kütüphanesi ile farklı cache store providerları kullanmak mümkün. Ancak kütüphane içerisinde şu an sadece InMemory cache store providerı var. İnternet'te araştırma yaptığımda [Redis](http://www.nuget.org/packages/EFCache.Redis/2014.11.28.1) providerı bulabildim. Ancak custom providerlar da yazmak mümkün. Sonuçta herşey `ICache`'i implemente etmeye bakıyor.

## Custom Caching Policy ##

Entity Framework second-level cache kütüphanesi default olarak herşeyi cacheliyor. Bu da duruma göre doğru bir şey olmayabilir. Eğer uygulamanızda sorgu çektiğiniz tablolara update ve insert yapılıyorsa sorgular sonucunda yapılan update ve insertleri okuma işleminde göremezsiniz. Bu nedenle özel bir `CachingPolicy` tanımlayıp işimize yarayan yerleri cachelemekte fayda var. Gelelim bu işi nasıl yapacağımıza. 

Kendi `CachingPolicy`'mizi yazmak için yeni bir class yazıp o classı da `CachingPolicy` sınıfından türetmek gerekiyor. Sonrasında da `CachingPolicy` içerisindeki üç farklı metodu override ederek kendi caching policymizi yaratabiliyoruz. Caching policy içerisinde override edilebilecek olan üç metot şu şekilde.

<pre style="font-family:Consolas;font-size:19;color:black;background:white;"><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MyCachingPolicy</span>&nbsp;:&nbsp;<span style="color:#2b91af;">CachingPolicy</span><br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">protected</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">void</span>&nbsp;GetExpirationTimeout(System.Collections.ObjectModel.<span style="color:#2b91af;">ReadOnlyCollection</span>&lt;System.Data.Entity.Core.Metadata.Edm.<span style="color:#2b91af;">EntitySetBase</span>&gt;&nbsp;affectedEntitySets,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:#2b91af;">TimeSpan</span>&nbsp;slidingExpiration,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:#2b91af;">DateTimeOffset</span>&nbsp;absoluteExpiration)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absoluteExpiration&nbsp;=&nbsp;<span style="color:#2b91af;">DateTimeOffset</span>.MaxValue;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slidingExpiration&nbsp;=&nbsp;<span style="color:#2b91af;">TimeSpan</span>.MaxValue;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/> <br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">protected</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;CanBeCached(System.Collections.ObjectModel.<span style="color:#2b91af;">ReadOnlyCollection</span>&lt;System.Data.Entity.Core.Metadata.Edm.<span style="color:#2b91af;">EntitySetBase</span>&gt;&nbsp;affectedEntitySets,&nbsp;<span style="color:blue;">string</span>&nbsp;sql,&nbsp;<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">KeyValuePair</span>&lt;<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">object</span>&gt;&gt;&nbsp;parameters)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">base</span>.CanBeCached(affectedEntitySets,&nbsp;sql,&nbsp;parameters);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/> <br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">protected</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">void</span>&nbsp;GetCacheableRows(System.Collections.ObjectModel.<span style="color:#2b91af;">ReadOnlyCollection</span>&lt;System.Data.Entity.Core.Metadata.Edm.<span style="color:#2b91af;">EntitySetBase</span>&gt;&nbsp;affectedEntitySets,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:blue;">int</span>&nbsp;minCacheableRows,&nbsp;<span style="color:blue;">out</span>&nbsp;<span style="color:blue;">int</span>&nbsp;maxCacheableRows)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">base</span>.GetCacheableRows(affectedEntitySets,&nbsp;<span style="color:blue;">out</span>&nbsp;minCacheableRows,&nbsp;<span style="color:blue;">out</span>&nbsp;maxCacheableRows);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}</pre>

- `GetExpirationTimeout` metodunda adından da anlayabileceğiniz üzere cache'in expire olma süresini verebiliyoruz. Absolute ve sliding expiration vermek mümkün.
- `CanBeCached` metodunda ise sorgu sonucunda dönen entitylerin second-level cache tarafından cachelenip cachelenmeyeceğini söyleyebiliyoruz.
- `GetCacheableRows` metodunda ise cachelenecek minimum ve maximum row sayısını söyleyebiliyoruz.

Bu özelleştirme yapısında karşımıza çıkabilecek en önemli sorun cache policy configlerini nerede tutacağımız. Yani varsayalım ki contextiniz içerisinde on entityden sadece üçü için yapılacak sorguları cachelemek istiyorsunuz ve bu üç entity için de farklı expiration vermek istiyorsunuz. Bu configleri cache policy classınız içerisine koyabilirsiniz. Ama daha generic bir çözümle custom attribute yazıp oradan bu dataları çekmek isterseniz bunu yapmak biraz zor. Çünkü öncelikle size parametre olarak gelen  `affectedEntitySets` içerisinden dönen datanın hangi table'dan döndüğünü almanız gerekiyor. Bu bilgiyi `EntitySetBase` içerisindeki Table propertysinden alabilirsiniz. Sonrasında da Entity Framework metadatasını sorgulayarak o table'a map olan class'ı([Detaylı bilgi için](http://romiller.com/2014/04/08/ef6-1-mapping-between-types-tables/)) almanız gerekecek. Oradan da reflectionla attribute'ü okuyup ona uygun olarak değerleri verebilirsiniz. Bu durum biraz zor ve performansı düşüren bir uygulama olacaktır. Açıkcası EF metadatasını sorgulamanın performansa nasıl bir etki getireceğini test etmedim. O yüzden bu noktadan ilerlenecekse öncelikle bazı testlerin yapılmasında fayda var.

Entity framework second-level cache kütüphanesi özellikle readonly tabloların cachelenmesi konusunda basitliğini de göz önünde bulundurduğumuzda güzel bir çözüm. Ancak işler kompleksleştiğinde kullanımı oldukça zorlaşıyor. Örneğin istediğimiz durumda cache'i invalide etmemiz mümkün değil. Bunun yanında transaction içerisinde yapılan sorguların da cachelenmediğinden bahsetmemde fayda var. Projenin içerisinde bu özellik ToDo olarak bulunuyor. Ancak ne zaman kütüphane içerisine eklenir sorusuna cevap vermek zor. 
